1. MVVM (Model-View-ViewModel) adalah pola arsitektur yang sangat penting dalam pengembangan aplikasi modern karena memisahkan antara logika bisnis, data, dan antarmuka pengguna (UI). Pemisahan ini memberikan beberapa keuntungan utama:
	- Pemisahan Tanggung Jawab (Separation of Concerns): Setiap komponen memiliki tugas yang jelas. View hanya menampilkan data dan 	menangkap input pengguna. ViewModel menyiapkan data untuk View dan bereaksi terhadap input. Model merepresentasikan data dan logika 	bisnis.
	- Meningkatkan Kemudahan Pengujian (Testability): Karena ViewModel tidak memiliki referensi langsung ke View (Android Framework), 	logikanya dapat diuji dengan mudah menggunakan unit test sederhana, yang jauh lebih cepat dan andal.
	- Meningkatkan Kemudahan Perawatan (Maintainability): Ketika logika terpisah dari UI, mengubah tampilan (misalnya, dari Activity ke 	Fragment) tidak mengharuskan perubahan besar pada logika bisnis di ViewModel.
	- Mengatasi Masalah Siklus Hidup (Lifecycle-Awareness): Komponen ViewModel pada Android dirancang untuk bertahan dari perubahan 	konfigurasi (seperti rotasi layar) yang biasanya menghancurkan dan membuat ulang Activity atau Fragment. Ini mencegah hilangnya data 	UI dan panggilan jaringan yang tidak perlu.
Berdasarkan file-file dalam tutorial:
	- Model: Movie.kt. Kelas ini merepresentasikan struktur data film dan juga bertindak sebagai entity database.
	- View: MainActivity.kt dan file layout XML-nya (activity_main.xml). Bagian ini bertanggung jawab untuk menampilkan daftar film 	kepada pengguna.
	- ViewModel: MovieViewModel.kt. Kelas ini mengambil data dari MovieRepository dan menyiapkannya dalam bentuk StateFlow agar dapat 	diamati dan ditampilkan oleh MainActivity.

2. Data Binding lebih efisien dibandingkan metode normal (seperti menggunakan findViewById atau View Binding) karena beberapa alasan:
	- Mengurangi Kode Boilerplate: Anda tidak perlu menulis kode findViewById atau binding.textView.text = ... secara manual di dalam 	Activity atau Fragment. Sebagai gantinya, Anda dapat mengikat data langsung dari ViewModel ke file layout XML. Ini membuat kode di 	sisi View (misalnya, MainActivity.kt) menjadi lebih bersih dan ringkas.
	- Pembaruan UI Otomatis: Ketika Anda menggunakan komponen yang dapat diamati seperti StateFlow atau LiveData dari ViewModel, Data 	Binding dapat secara otomatis memperbarui UI setiap kali data berubah. Tanpa Data Binding, Anda harus secara manual mengobservasi 	perubahan dan mengatur data ke setiap View, yang lebih rentan terhadap kesalahan.
	- Performa: Saat pertama kali dikompilasi, Data Binding menghasilkan kelas-kelas yang diperlukan untuk mengakses View. Akses ini 	terjadi dalam satu kali proses penelusuran hierarki View, yang membuatnya lebih cepat daripada findViewById yang harus menelusuri 	hierarki untuk setiap pemanggilan.

3. Pola Singleton sangat penting saat membuat instance database (MovieDatabase.kt) karena:
	- Mencegah Pemborosan Sumber Daya: Membuat koneksi ke database adalah operasi yang mahal dan memakan banyak sumber daya (memori 	dan waktu proses). Dengan pola Singleton, Anda memastikan bahwa hanya ada satu instance database dan satu koneksi yang dibuat 	selama aplikasi berjalan.
	- Menghindari Masalah Integritas Data: Jika ada beberapa instance dari database yang sama, mereka bisa mencoba membaca dan menulis 	ke file database secara bersamaan. Hal ini dapat menyebabkan race condition, kerusakan data, atau state aplikasi yang tidak 	konsisten.
	- Sebagai Satu Titik Akses (Single Point of Access): Pola Singleton menyediakan satu titik akses global yang aman untuk 	mendapatkan instance database dari mana saja di aplikasi, memastikan semua bagian aplikasi menggunakan objek database yang sama.

4. Pola Repository (MovieRepository.kt) sangat penting karena bertindak sebagai lapisan abstraksi antara sumber data dan bagian lain dari aplikasi (seperti ViewModel). Manfaat utamanya adalah:
	- Sebagai Sumber Kebenaran Tunggal (Single Source of Truth): Repository menggabungkan logika untuk memutuskan dari mana data harus 	diambil. Dalam tutorial Anda, Repository memutuskan apakah akan mengambil data dari database lokal (Room) atau dari jaringan (API 	Retrofit).
	- Abstraksi Sumber Data: ViewModel tidak perlu tahu atau peduli apakah data berasal dari API, database, atau cache di memori. 	ViewModel hanya meminta data ke Repository. Ini membuat ViewModel lebih sederhana dan memungkinkan Anda untuk mengubah cara 	pengambilan data (misalnya, mengganti Retrofit dengan library lain) tanpa harus mengubah ViewModel.
	- Meningkatkan Kemudahan Pengujian: Anda dapat dengan mudah membuat "fake repository" (repositori tiruan) untuk menguji ViewModel. 	Fake repository ini bisa mensimulasikan data dari jaringan atau database tanpa benar-benar melakukan panggilan jaringan atau query 	database, membuat pengujian menjadi lebih cepat dan terisolasi.

5. Ya, ada beberapa cara lain untuk menyegarkan database, meskipun WorkManager seringkali merupakan pilihan terbaik untuk tugas yang dapat ditunda dan terjamin. Alternatif lainnya antara lain:
	1). Menggunakan Coroutine Scope di Application atau ViewModel: Anda bisa meluncurkan coroutine yang berjalan dalam scope yang 	lebih panjang (seperti GlobalScope atau scope kustom yang terikat pada siklus hidup aplikasi). Coroutine ini bisa memiliki loop 	dengan delay() untuk berjalan secara periodik.
		- Kelemahan: Metode ini kurang andal. Jika sistem Android mematikan proses aplikasi Anda untuk menghemat memori, coroutine 		tersebut akan berhenti dan tidak akan dimulai ulang secara otomatis.
	2). Menggunakan AlarmManager: Ini adalah komponen Android yang lebih tua untuk menjadwalkan pekerjaan pada waktu tertentu di masa 	depan, bahkan jika aplikasi tidak berjalan. AlarmManager dapat digunakan untuk memicu BroadcastReceiver atau Service yang kemudian 	akan menyegarkan database.
		- Kelemahan: AlarmManager kurang efisien dalam penggunaan baterai dan lebih kompleks untuk diimplementasikan dengan benar, 		terutama pada versi Android modern yang memiliki banyak batasan untuk pekerjaan di latar belakang.
	3). Menggunakan Firebase Cloud Messaging (FCM): Anda bisa mengirim silent push notification (notifikasi senyap) dari server Anda. 	Ketika aplikasi menerima notifikasi ini, ia dapat memicu proses penyegaran data di latar belakang.
		- Kelemahan: Ini memerlukan infrastruktur backend (server) untuk mengirim notifikasi dan tidak cocok untuk penyegaran data 		yang murni berbasis interval waktu di sisi klien.
	WorkManager adalah solusi yang direkomendasikan oleh Google karena ia mengabstraksikan kompleksitas ini. Ia secara cerdas memilih 	cara terbaik (apakah menggunakan AlarmManager atau JobScheduler di balik layar) untuk menjalankan tugas berdasarkan versi Android 	dan kondisi perangkat, sambil tetap menghormati batasan sistem dan efisiensi baterai.